# **Архитектурный анализ и стратегии реализации векторного поиска в среде SQLite: Применение расширения sqlite-vec для локальных баз знаний масштаба 500 000 записей**

## **1\. Введение: Смена парадигмы в локальных системах хранения данных**

К ноябрю 2025 года ландшафт разработки программного обеспечения, ориентированного на локальное хранение данных («Local-First»), претерпел фундаментальные изменения. Традиционные методы информационного поиска, базирующиеся на лексическом сопоставлении (BM25, TF-IDF), перестали удовлетворять возрастающие потребности пользователей, ожидающих от своих персональных баз знаний («Second Brain») уровня интеллектуального понимания, сравнимого с большими языковыми моделями (LLM). В условиях, когда конфиденциальность данных становится приоритетом, а зависимость от облачных API рассматривается как архитектурный риск, возникла острая необходимость в эффективных, встраиваемых инструментах векторного поиска.  
Данный отчет посвящен всестороннему исследованию архитектурных возможностей расширения sqlite-vec для реализации гибридного поиска в базе данных заметок объемом 500 000 записей. Этот объем данных представляет собой специфический класс инженерных задач: он превышает возможности тривиальных решений in-memory, но часто не оправдывает внедрение тяжеловесных кластерных векторных баз данных, таких как Qdrant или Milvus, в локальную среду пользователя. Мы детально рассмотрим, как эволюция экосистемы SQLite, в частности переход от экспериментального sqlite-vss к стабильному sqlite-vec, открывает новые возможности для создания высокопроизводительных систем поиска без внешних зависимостей.  
Центральной темой исследования является не просто хранение векторов, но построение комплексной системы гибридного ранжирования, учитывающей семантику текста, метаданные (теги, категории) и динамику обновления информации. Анализ проводится с учетом актуальности технологий на конец 2025 года, включая поддержку бинарного квантования, матрешка-эмбеддингов и партиционирования.

## **2\. Архитектура и Внутреннее Устройство sqlite-vec**

### **2.1. Отказ от внешних зависимостей как стратегическое преимущество**

История векторного поиска в SQLite до 2024 года была неразрывно связана с расширением sqlite-vss, которое фактически являлось оберткой над библиотекой Faiss от Facebook AI Research. Несмотря на функциональную мощь, sqlite-vss страдал от значительных проблем с переносимостью: зависимость от C++ библиотек, сложность компиляции под экзотические архитектуры (например, Raspberry Pi или WASM) и проблемы с управлением памятью при частых обновлениях данных (OLTP-нагрузка).  
С появлением sqlite-vec (версии v0.1.x, актуальной на ноябрь 2025 года) архитектурная парадигма сменилась. Расширение было полностью переписано на чистом C без внешних зависимостей. Это решение имеет далеко идущие последствия для архитектуры локальных приложений:

1. **Универсальная переносимость:** sqlite-vec компилируется в единый файл расширения, работающий везде, где работает SQLite, включая браузерные среды через WebAssembly (WASM) и мобильные устройства.  
2. **Предсказуемое управление ресурсами:** Отказ от Faiss позволил разработчикам sqlite-vec реализовать собственные механизмы управления памятью, тесно интегрированные со страничным кэшем SQLite, что критически важно для работы с базами данных, превышающими объем RAM.

### **2.2. Виртуальные таблицы vec0 и механизм Shadow Tables**

В основе sqlite-vec лежит концепция виртуальных таблиц (Virtual Tables) SQLite. При создании таблицы с использованием модуля vec0, разработчик декларирует структуру, которая внешне ведет себя как обычная таблица SQL, но внутри реализует специализированную логику хранения и доступа.  
`CREATE VIRTUAL TABLE vec_notes USING vec0(`  
  `embedding float,`  
  `+created_at text,`  
  `+tags text`  
`);`

Внутренне sqlite-vec использует так называемые «теневые таблицы» (shadow tables) — реальные B-Tree таблицы SQLite, в которых векторы хранятся в виде BLOB-объектов. Однако, в отличие от наивного хранения векторов, sqlite-vec организует данные в «чанки» (chunks). Это позволяет оптимизировать операции ввода-вывода (I/O) и использовать SIMD-инструкции процессора (AVX-512 на x86\_64 или NEON на ARM) для одновременной обработки групп векторов.  
Для базы данных в 500 000 записей такая организация хранения обеспечивает баланс между скоростью последовательного чтения (необходимого для полного перебора) и эффективностью точечных обновлений, так как при изменении одного вектора не требуется перезаписывать весь файл индекса, а лишь соответствующую страницу данных.

## **3\. Проблема Индексации: Анализ Методов Доступа для 500 000 векторов**

### **3.1. Отсутствие HNSW и IVF: Архитектурный компромисс**

Одним из наиболее часто задаваемых вопросов при проектировании векторного поиска является выбор типа индекса: HNSW (Hierarchical Navigable Small World), IVF (Inverted File) или Flat (полный перебор). На момент ноября 2025 года, sqlite-vec **официально не поддерживает** построение приближенных индексов (ANN), таких как HNSW или DiskANN, внутри самого расширения, полагаясь исключительно на оптимизированный полный перебор (Brute-force).  
Этот факт может показаться критическим недостатком по сравнению с pgvector (который поддерживает HNSW), однако для масштаба в 500 000 записей решение использовать Brute-force является обоснованным инженерным компромиссом, основанным на следующих факторах:

1. **Mutable Graph Problem:** Графовые индексы, такие как HNSW, крайне сложно поддерживать в актуальном состоянии при интенсивных операциях записи и удаления. Удаление узла из графа требует сложной перестройки связей, что противоречит транзакционной природе SQLite и требованиям ACID. sqlite-vec, ориентированный на OLTP (Online Transaction Processing), отдает приоритет скорости вставки и надежности данных.  
2. **Накладные расходы на память (Memory Overhead):** Индексы HNSW требуют хранения графа связей. Для 500 000 векторов структура графа может занимать объем памяти, сопоставимый или превышающий объем самих векторов. В условиях локального устройства это нерациональное использование ресурсов.  
3. **Векторизация вычислений:** Современные процессоры способны вычислять дистанцию между векторами с огромной скоростью. На масштабе до 1 миллиона векторов оптимизированный полный перебор часто оказывается конкурентоспособным по времени, обеспечивая при этом 100% точность (Recall), чего не могут гарантировать ANN-индексы.

### **3.2. Математика масштабирования: Расчет нагрузки для 500k записей**

Рассмотрим базу заметок объемом 500 000 записей. Предположим использование популярной модели эмбеддингов с размерностью d=768 (например, nomic-embed-text-v1.5 или all-MiniLM-L6-v2).  
В стандартном формате float32 (4 байта на измерение) размер одного вектора составляет:  
Общий объем данных для 500 000 записей:  
При выполнении поискового запроса методом полного перебора системе необходимо прочитать из памяти (или с диска) и обработать 1.5 ГБ данных. Для современных SSD (скорость чтения 3-7 ГБ/с) и оперативной памяти (десятки ГБ/с) это выполнимая задача, однако латентность может составлять 100–300 мс, что находится на грани комфортного восприятия пользователем («UI freeze»).  
Для оптимизации этого процесса sqlite-vec предлагает механизмы сжатия, которые делают индексы HNSW ненужными на данном масштабе.

## **4\. Стратегии Оптимизации: Квантование и Матрешка-эмбеддинги**

### **4.1. Бинарное Квантование (Binary Quantization)**

Наиболее мощным инструментом оптимизации производительности в sqlite-vec является поддержка бинарных векторов. Бинарное квантование преобразует 32-битные числа с плавающей запятой в 1-битные значения, основываясь на знаке числа (положительное или отрицательное).  
В sqlite-vec это реализуется функцией vec\_quantize\_binary() и типом данных bit. Пересчитаем объем данных для 500 000 записей при использовании бинарного квантования (d=768):  
Сжатие данных с 1.5 ГБ до 48 МБ (в 32 раза) кардинально меняет профиль производительности:

1. **Попадание в кэш CPU:** 48 МБ данных могут полностью поместиться в L3-кэш высокопроизводительных процессоров или гарантированно оставаться в оперативной памяти даже на бюджетных устройствах.  
2. **Ускорение вычислений:** Вместо сложных операций с плавающей запятой (FMA), процессор использует инструкции XOR и POPCNT (подсчет единичных битов) для вычисления дистанции Хэмминга. Это одни из самых быстрых инструкций в архитектуре CPU.

Тесты показывают, что использование бинарного квантования позволяет сократить время поиска по 1 миллиону векторов до 10–20 мс, что в 10 раз быстрее «золотого стандарта» в 100 мс. При этом потеря точности (accuracy drop) для современных моделей составляет всего 3–5%, что абсолютно приемлемо для поиска по личным заметкам.  
**Практическая реализация:** Для использования бинарного квантования необходимо выбрать модель эмбеддингов, обученную для этого (например, mixedbread-ai/mxbai-embed-large-v1 или nomic-embed-text-v1.5). Обычные модели могут показать значительное падение качества при бинаризации.

### **4.2. Матрешка-эмбеддинги (Matryoshka Representation Learning)**

Альтернативной или дополняющей стратегией является использование Матрешка-эмбеддингов (MRL). Эта технология позволяет усекать вектор (например, использовать только первые 256 измерений из 768\) с сохранением основной семантической информации.  
В sqlite-vec это реализуется через функцию vec\_slice().  
`SELECT rowid, distance`
`FROM vec_notes`
`WHERE vec_slice(embedding, 0, 256) MATCH vec_slice(:query, 0, 256)`  
`ORDER BY distance`

Это позволяет линейно сократить объем вычислений. Для базы в 500 000 записей можно применять каскадный поиск:

1. Быстрый поиск по усеченным векторам (или бинарным) для отбора топ-200 кандидатов.  
2. Переранжирование (Re-ranking) топ-200 кандидатов с использованием полных векторов для максимальной точности.

Такой подход позволяет совместить скорость приближенного поиска и точность полного перебора, не прибегая к сложным внешним индексам.

## **5\. Проектирование Схемы Данных: Тема, Описание и Хештеги**

Вопрос пользователя о влиянии настроек индексации (выбор полей для векторизации) является ключевым для качества поиска (Relevance Engineering). Векторный поиск — это поиск по смыслу, и от того, *какой именно* текст мы подаем на вход модели, зависит формирование семантического пространства.

### **5.1. Дилемма «Topic vs Description»**

Заметки часто имеют короткий заголовок (Topic) и длинное тело (Description).

* **Векторизация только заголовка:** Создает четкие, сфокусированные векторы. Однако, заголовки часто бывают неинформативны («Встреча 23.11», «Идеи»). Поиск по таким векторам приведет к низкому Recall (полноте).  
* **Векторизация всего текста:** Для длинных заметок это создает проблему «размывания» вектора. Модель пытается сжать тысячи слов в фиксированный вектор, усредняя все темы. Это может привести к тому, что заметка о «финансах» и «путешествиях» окажется в семантическом пространстве где\-то посередине, не находясь ни по одному из запросов.

### **5.2. Роль Хештегов и Стратегия Взвешивания**

Хештеги в заметках играют роль **семантических якорей**. Они обладают высочайшей информационной плотностью. Включение тегов в векторизуемый текст критически важно.  
**Рекомендуемая стратегия конкатенации:** Для достижения наилучших результатов при 500 000 записях рекомендуется формировать искусственный текстовый документ для векторизации, используя шаблон, понятный современным моделям (Instruction-tuned embeddings):  
Title: {Topic} Tags: {Hashtags} Content: {Description (truncated to 512 tokens)}  
Добавление префиксов Title:, Tags: помогает модели различать структурные части. Хештеги, добавленные в начало или конец, значительно влияют на вектор, смещая его в нужный кластер даже при наличии большого объема общего текста в описании.

### **5.3. Практический анализ влияния на результат**

| Стратегия индексации | Преимущества | Недостатки | Рекомендация |
| :---- | :---- | :---- | :---- |
| **Только Description** | Охватывает весь контекст. | Теряет фокус в длинных текстах. Низкий вес важных ключевых слов. | Не рекомендуется для заметок \> 200 слов. |
| **Topic \+ Description** | Улучшает навигацию. | Заголовки могут быть «шумными». | Базовый вариант. |
| **Topic \+ Tags \+ Description** | **Максимальная релевантность.** Теги работают как «мягкий фильтр». | Требует тщательного ведения тегов пользователем. | **Рекомендуемый стандарт.** |

Использование тегов внутри эмбеддинга позволяет находить заметки по запросу «финансы», даже если слово «финансы» не встречается в тексте, но есть тег \#budget. Это значительно повышает качество поиска по сравнению с чистым полнотекстовым поиском.

## **6\. Реализация Гибридного Поиска и Ранжирование**

Гибридный поиск — это методика объединения результатов семантического (векторного) поиска и поиска по ключевым словам (Lexical/FTS). Для локального хранилища заметок это необходимость: пользователь может помнить точную цитату (FTS) или только общую идею (Vector).

### **6.1. Reciprocal Rank Fusion (RRF) как стандарт де\-факто**

Основная проблема гибридного поиска — несоразмерность шкал. Векторный поиск возвращает косинусное расстояние (обычно от 0.0 до 1.0), а полнотекстовый поиск (FTS5 в SQLite) возвращает скор BM25, который может быть любым отрицательным числом (в реализации SQLite FTS5 скор часто инвертирован и не нормализован).  
Простое сложение (0.8 \+ (-15.4)) бессмысленно. Алгоритм **Reciprocal Rank Fusion (RRF)** решает эту проблему, игнорируя абсолютные значения и работая только с *позицией* (рангом) документа в выдаче.  
Формула RRF:  
Где k — константа сглаживания (обычно 60). Этот метод штрафует документы, находящиеся далеко в списке, и поощряет те, что найдены обоими методами.

### **6.2. SQL-реализация Гибридного Поиска (Common Table Expressions)**

Для 500 000 записей эффективная реализация RRF требует использования Common Table Expressions (CTE) для выполнения двух параллельных поисков и последующего слияния.  
Ниже приведен оптимизированный SQL-запрос для sqlite-vec:  
`WITH`
  `-- 1. Векторный поиск (Семантика)`  
  `vec_matches AS (`  
    `SELECT`
      `rowid,`
      `distance,`  
      `-- Вычисляем ранг внутри векторной выдачи`  
      `ROW_NUMBER() OVER (ORDER BY distance) as rank_vec`  
    `FROM vec_notes`
    `WHERE embedding MATCH :query_vec`  
      `AND k = 100 -- Берем топ-100 кандидатов`  
  `),`  

  `-- 2. Полнотекстовый поиск (Ключевые слова)`  
  `fts_matches AS (`  
    `SELECT`
      `rowid,`
      `rank,`  
      `-- Вычисляем ранг внутри текстовой выдачи`  
      `ROW_NUMBER() OVER (ORDER BY rank) as rank_fts`  
    `FROM fts_notes`
    `WHERE fts_notes MATCH :query_text`
    `ORDER BY rank`
    `LIMIT 100 -- Берем топ-100 кандидатов`  
  `),`  

  `-- 3. Слияние результатов (Full Outer Join)`  
  `all_matches AS (`  
    `SELECT`
      `COALESCE(v.rowid, f.rowid) as rowid,`  
      `v.rank_vec,`  
      `f.rank_fts`  
    `FROM vec_matches v`  
    `FULL OUTER JOIN fts_matches f ON v.rowid = f.rowid`  
  `)`

`-- 4. Финальное вычисление RRF Score`  
`SELECT`
  `m.rowid,`  
  `n.title,`  
  `n.description,`  
  `(`  
    `COALESCE(1.0 / (60 + m.rank_vec), 0.0) +`
    `COALESCE(1.0 / (60 + m.rank_fts), 0.0)`  
  `) as rrf_score`  
`FROM all_matches m`  
`JOIN notes n ON m.rowid = n.id`  
`ORDER BY rrf_score DESC`  
`LIMIT 20;`

.  
Этот запрос является «золотым стандартом» для гибридного поиска в SQLite. Использование COALESCE гарантирует, что если документ найден только одним методом (например, только по вектору), он все равно попадет в выдачу, но с меньшим весом. Константа 60 в знаменателе эмпирически доказана как оптимальная для балансировки влияния FTS и векторов.

## **7\. Фильтрация и Категоризация: «Похожее в категории»**

Пользовательский запрос содержит требование искать «похожее в категории». Это классическая задача фильтрованного векторного поиска (Filtered Vector Search). В sqlite-vec существуют два основных механизма для этого, и выбор зависит от типа фильтра.

### **7.1. Partition Keys (Партиционирование)**

Для жестких, взаимоисключающих категорий (например, Папка, ID Пользователя, Год) sqlite-vec с версии 0.1.6 поддерживает **Partition Keys**.  
`CREATE VIRTUAL TABLE vec_notes USING vec0(`  
  `embedding float,`  
  `category_id integer partition key`  
`);`

При использовании partition key в запросе:  
`SELECT... FROM vec_notes WHERE embedding MATCH :q AND category_id = 5`

Движок sqlite-vec физически ограничивает поиск только теми чанками данных, которые относятся к category\_id \= 5\. Это обеспечивает линейное ускорение. Если 500 000 заметок равномерно распределены по 50 папкам, поиск будет идти всего по 10 000 записей, что происходит мгновенно (\< 1 мс).

### **7.2. Проблема Many-to-Many тегов и Pre-filtering**

Сложнее обстоит дело с тегами, где одна заметка может иметь несколько тегов (связь многие-ко-многим). sqlite-vec пока не поддерживает сложные JOIN внутри условия MATCH.  
Для фильтрации по тегам (например, «найти похожее с тегом \#работа») необходимо использовать стратегию **Pre-filtering с использованием rowid IN**. sqlite-vec оптимизирован для обработки подзапросов, возвращающих список rowid.  
Оптимизированный запрос для фильтрации по тегам:  
`SELECT rowid, distance[span_19](start_span)[span_19](end_span)`
`FROM vec_notes`
`WHERE embedding MATCH :query_vec`  
  `AND k = 50`  
  `AND rowid IN (`  
    `-- Быстрый выбор ID из обычной реляционной таблицы тегов`  
    `SELECT note_id`
    `FROM note_tags`
    `WHERE tag_id = (SELECT id FROM tags WHERE name = 'работа')`  
  `);`

В этом сценарии SQLite сначала выполняет вложенный запрос (который очень быстр благодаря B-Tree индексам), получает список допустимых rowid, и передает их в sqlite-vec. Векторный движок затем вычисляет дистанцию *только* для этих векторов. Это значительно эффективнее, чем Post-filtering (поиск всех похожих и отбрасывание ненужных), так как гарантирует получение заданного k результатов.

## **8\. Операционный цикл: Обновление информации и Перестроение индексов**

Одной из критических проблем внешних векторных индексов (Faiss, HNSWLib) является сложность обновления. В sqlite-vec эта проблема решена архитектурно.

### **8.1. OLTP-совместимость и Транзакционность**

sqlite-vec спроектирован как OLTP (Online Transaction Processing) движок. Операции INSERT, UPDATE и DELETE являются первоклассными гражданами.

* **Вставка:** Новый вектор сразу же становится доступным для поиска. Не требуется процедура «фиксации» или «мерджа» сегментов.  
* **Удаление:** При удалении записи, sqlite-vec помечает соответствующий вектор как удаленный в битовой маске валидности. Это операция O(1).  
* **Обновление:** Изменение вектора (например, при редактировании текста заметки) реализуется как атомарная транзакция (удаление старого \+ вставка нового).

Для 500 000 записей это означает, что пользователь не сталкивается с ситуацией «устаревшего индекса». Перестраивание индексов (Reindexing) как отдельный процесс **не требуется**. Индекс всегда актуален.

### **8.2. Обслуживание (VACUUM)**

Единственной рекомендуемой процедурой обслуживания является периодический запуск команды VACUUM. Поскольку sqlite-vec использует теневые таблицы, интенсивные обновления могут приводить к фрагментации страниц на диске. VACUUM пересобирает файл базы данных, уплотняя данные и потенциально ускоряя последовательное чтение при полном переборе.

### **8.3. Резервное копирование и WAL-режим**

Для обеспечения надежности и производительности настоятельно рекомендуется использовать режим **WAL (Write-Ahead Logging)**:  
`PRAGMA journal_mode = WAL;`  
`PRAGMA synchronous = NORMAL;`

Это позволяет выполнять операции чтения и записи параллельно, что критично для интерактивного интерфейса заметок. sqlite-vec полностью совместим с инструментами потоковой репликации SQLite, такими как Litestream, что позволяет организовать Disaster Recovery без остановки работы.

## **9\. Сравнительный анализ и Заключение**

### **9.1. Сравнение с альтернативами (PGVector, Faiss)**

| Характеристика | sqlite-vec (2025) | PostgreSQL \+ pgvector | SQLite \+ Faiss (Python) |
| :---- | :---- | :---- | :---- |
| **Архитектура** | Встраиваемая (C ext) | Клиент-Сервер | Встраиваемая (но сложный деплой) |
| **Индексы** | Brute-force / Binary Quantization | HNSW / IVFFlat | HNSW / IVF |
| **Сложность (Ops)** | Минимальная (1 файл) | Высокая (Docker/Server) | Средняя (Python env) |
| **Память (500k)** | \~50 МБ (Binary) | Зависит от HNSW графа (сотни МБ) | Зависит от индекса |
| **Обновления** | Real-time (OLTP) | Real-time | Сложные (Rebuild required) |
| **Гибридный поиск** | Ручной (SQL CTE) | Встроенный (RRF functions) | Сложный (разные системы) |

### **9.2. Итоговые выводы**

Исследование показывает, что к ноябрю 2025 года sqlite-vec является оптимальным решением для локального хранилища заметок объемом 500 000 записей. Отсутствие сложных графовых индексов (HNSW) не является препятствием благодаря эффективной реализации бинарного квантования и полной интеграции с механизмом виртуальных таблиц SQLite.  
**Ключевые рекомендации для реализации:**

1. **Использовать Бинарное Квантование:** Это снижает требования к памяти в 32 раза и ускоряет поиск до \<20 мс, делая его неотличимым от индексированного поиска.  
2. **Внедрить RRF через CTE:** Это единственный надежный способ качественно объединить лексический и семантический поиск без ручной подстройки весов.  
3. **Использовать Partition Keys и Pre-filtering:** Для реализации фасетного поиска («похожее в категории») использовать встроенные механизмы партиционирования и фильтрации по rowid.  
4. **Векторизовать Теги:** Включать хештеги в тело эмбеддинга для усиления семантического сигнала.

Данная архитектура обеспечивает создание robust-системы («Local Second Brain»), которая работает быстро, уважает приватность пользователя и не требует сложного администрирования.

#### **Источники**

1\. asg017/sqlite-vec: A vector search SQLite extension that runs anywhere\! \- GitHub, <https://github.com/asg017/sqlite-vec> 2\. Embedded Intelligence: How SQLite-vec Delivers Fast, Local Vector Search for AI., <https://dev.to/aairom/embedded-intelligence-how-sqlite-vec-delivers-fast-local-vector-search-for-ai-3dpb> 3\. How sqlite-vec Works for Storing and Querying Vector Embeddings | by Stephen Collins, <https://medium.com/@stephenc211/how-sqlite-vec-works-for-storing-and-querying-vector-embeddings-165adeeeceea> 4\. What's the best vector database for building AI products? | Liveblocks blog, <https://liveblocks.io/blog/whats-the-best-vector-database-for-building-ai-products> 5\. Binary Quantization | sqlite-vec \- Alex Garcia, <https://alexgarcia.xyz/sqlite-vec/guides/binary-quant.html> 6\. Introducing sqlite-vec v0.1.0: a vector search SQLite extension that runs everywhere | Alex Garcia's Blog, <https://alexgarcia.xyz/blog/2024/sqlite-vec-stable-release/index.html> 7\. sqlite-vec now supports metadata columns and filtering | Alex Garcia's Blog, <https://alexgarcia.xyz/blog/2024/sqlite-vec-metadata-release/index.html> 8\. asg017/sqlite-vss: A SQLite extension for efficient vector search, based on Faiss\! \- GitHub, <https://github.com/asg017/sqlite-vss> 9\. Introducing sqlite-vec v0.1.0: a vector search SQLite extension that runs everywhere \- Reddit, <https://www.reddit.com/r/LocalLLaMA/comments/1ehlazq/introducing\_sqlitevec\_v010\_a\_vector\_search\_sqlite/> 10\. sqlite-vec-wasm 0.1.0 on npm \- Libraries.io \- security & maintenance, <https://libraries.io/npm/sqlite-vec-wasm> 11\. I'm writing a new vector search SQLite Extension | Alex Garcia's Blog, <https://alexgarcia.xyz/blog/2024/building-new-vector-search-sqlite/index.html> 12\. How sqlite-vec Works for Storing and Querying Vector Embeddings \- DEV Community, <https://dev.to/stephenc222/how-sqlite-vec-works-for-storing-and-querying-vector-embeddings-2g9b> 13\. ANN (Approximate Nearest Neighbors) Index · Issue \#25 · asg017/sqlite-vec \- GitHub, <https://github.com/asg017/sqlite-vec/issues/25> 14\. I'm writing a new vector search SQLite Extension \- Hacker News, <https://news.ycombinator.com/item?id=40243168> 15\. Instant Semantic Search API: SQLite FTS5 \+ Python FastAPI \- Stackademic, <https://blog.stackademic.com/instant-semantic-search-api-sqlite-fts5-python-fastapi-3298c6776935> 16\. API Reference | sqlite-vec \- Alex Garcia, <https://alexgarcia.xyz/sqlite-vec/api-reference.html> 17\. SQLite Extensions \- rqlite, <https://rqlite.io/docs/guides/extensions/> 18\. Binary Quantized Embeddings \- Kyle Howells, <https://ikyle.me/blog/2025/binary-quantized-embeddings> 19\. Building a Local Arxiv Paper Search Engine \- datascience.fm, <https://datascience.fm/building-a-local-arxiv-paper-search-engine/> 20\. sqlite-vec/site/api-reference.md at main \- GitHub, <https://github.com/asg017/sqlite-vec/blob/main/site/api-reference.md> 21\. What is semantic search? How it works, use cases & more \- Meilisearch, <https://www.meilisearch.com/blog/semantic-search> 22\. Simon Willison on vector-search, <https://simonwillison.net/tags/vector-search/> 23\. Reciprocal Rank Fusion (RRF) explained in 4 mins — How to score results form multiple retrieval methods in RAG | by Deval Shah | Medium, <https://medium.com/@devalshah1619/mathematical-intuition-behind-reciprocal-rank-fusion-rrf-explained-in-2-mins-002df0cc5e2a> 24\. Simon Willison on sql, <https://simonwillison.net/tags/sql/> 25\. Optimizing Hybrid Search Query with Reciprocal Rank Fusion (RRF) | Server \- MariaDB, <https://mariadb.com/docs/server/reference/sql-structure/vectors/optimizing-hybrid-search-query-with-reciprocal-rank-fusion-rrf> 26\. sqlite-vec Update Introduces Metadata Columns, Partitioning, and Auxiliary Features for Enhanced Data Retrieval: Transforming Vector Search \- MarkTechPost, <https://www.marktechpost.com/2024/11/25/sqlite-vec-update-introduces-metadata-columns-partitioning-and-auxiliary-features-for-enhanced-data-retrieval-transforming-vector-search/> 27\. What you need to know about SQLite \- Joy of Rails, <https://joyofrails.com/articles/what-you-need-to-know-about-sqlite>
