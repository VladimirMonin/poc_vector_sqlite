# Руководство по миграции SemanticCore из Flask в Django

> Анализ Flask-приложения и рекомендации по переносу логики в Django-проект с новой структурой данных (блог с постами, категориями, тегами).

---

## 1. Обзор текущей архитектуры Flask

Flask-приложение (`examples/flask_app/`) построено по принципу **слоистой архитектуры**:

```
┌─────────────────────────────────────────────────────────┐
│                    HTTP Layer (Routes)                  │
│   main.py │ search.py │ ingest.py │ chat.py │ settings  │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              Service Layer (бизнес-логика)              │
│   SearchService │ ChatService │ UploadService │ Cache   │
└─────────────────────────┬───────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                    SemanticCore                         │
│          (библиотека семантического поиска)             │
└─────────────────────────────────────────────────────────┘
```

**Ключевой принцип:** бизнес-логика отделена от HTTP-слоя и фреймворк-специфичных зависимостей.

---

## 2. Оценка переносимости компонентов

### 2.1 Компоненты, готовые к переносу (90-100%)

| Компонент | Готовность | Причина |
|-----------|------------|---------|
| `SearchService` | ✅ 100% | Нет импортов Flask, чистая бизнес-логика |
| `ChatService` | ✅ 100% | Работает через RAGEngine, framework-agnostic |
| `QueryCacheService` | ✅ 95% | Только Peewee + numpy, легко переписать на Django ORM |
| DTOs (dataclasses) | ✅ 100% | `SearchResultItem`, `ChatResponse` — чистые Python классы |
| `markdown.py` | ✅ 100% | Только markdown-it-py |

### 2.2 Компоненты, требующие адаптации

| Компонент | Объём работы | Что менять |
|-----------|--------------|------------|
| `extensions.py` | Средний | DI механизм — заменить `current_app.extensions` на Django |
| `routes/ingest.py` | Значительный | Много логики в контроллере — вынести в `IngestService` |
| Peewee модели | Переписать | `ChatSessionModel`, `SearchQueryModel` → Django ORM |
| Jinja2 шаблоны | Переписать | Синтаксис Django templates отличается |

### 2.3 Компоненты для полной замены

- **Routes** — Django views пишутся с нуля (разная философия)
- **Конфигурация** — Pydantic Settings → Django settings + django-environ

---

## 3. Стратегия переноса сервисов

### 3.1 Принцип: копируем логику, адаптируем инфраструктуру

**SearchService** — эталонный пример переносимого кода:

1. Принимает `SemanticCore` и `QueryCacheService` через конструктор (DI)
2. Не знает о Flask (нет `request`, `session`, `current_app`)
3. Возвращает чистые DTO, а не HTTP-ответы
4. Логирует через стандартный logger

**Адаптация для Django:**

1. Скопировать класс `SearchService` без изменений
2. Заменить инициализацию: вместо `current_app.extensions` — Django DI
3. Сохранить интерфейс методов

### 3.2 Инициализация SemanticCore в Django

В Flask используется паттерн Application Factory с extensions:

```
# Flask: app.extensions["semantic_core"] = core
```

В Django рекомендуется:

**Вариант A: Singleton через модуль**

- Создать `semantic_services.py` с lazy-инициализацией
- Импортировать во views по необходимости

**Вариант B: django-injector**

- Использовать DI-контейнер
- Регистрировать SemanticCore как singleton

**Вариант C: Django settings + factory**

- Хранить конфигурацию в settings.py
- Создавать экземпляр при первом обращении

---

## 4. Интеграция с новой структурой данных

### 4.1 Проблема: две модели данных

**SemanticCore** работает с абстрактными `Document` и `Chunk`:

- `Document` — единица индексации (markdown-файл, изображение)
- `Chunk` — фрагмент с эмбеддингом для поиска
- Метаданные хранятся в JSON-поле

**Django-блог** имеет свою структуру:

- `Post` — статья с заголовком, контентом
- `Category` — рубрика
- `Tag` — тег (many-to-many)

### 4.2 Варианты интеграции

#### Вариант 1: Дублирование данных (рекомендуется)

Django ORM хранит структурированные данные (CRUD):

- `Post`, `Category`, `Tag` — полная бизнес-логика
- Связи, валидация, админка

SemanticCore хранит векторы для поиска:

- При сохранении Post → автоматически индексируем в SemanticCore
- В metadata сохраняем `post_id`, `category_slug`, `tags`
- Поиск возвращает `post_id` → делаем JOIN с Django

**Плюсы:**

- Разделение ответственности
- Можно использовать PostgreSQL для Django + SQLite для векторов
- SemanticCore не знает о вашей бизнес-логике

**Минусы:**

- Нужна синхронизация при CRUD-операциях
- Два источника правды

#### Вариант 2: SemanticCore как единственное хранилище

Все данные поста хранятся в SemanticCore:

- Контент → для эмбеддинга
- Метаданные → категория, теги, дата

**Плюсы:**

- Нет дублирования
- Единый источник

**Минусы:**

- Теряем мощь Django ORM (связи, агрегации)
- Сложнее реализовать админку
- Не подходит для сложных бизнес-правил

#### Вариант 3: Гибрид с linking

Django ORM хранит структуру:

- `Post` с `semantic_doc_id` (ссылка на SemanticCore)

SemanticCore хранит контент и векторы:

- Индексация при создании/обновлении поста

**Поиск:**

1. Семантический поиск → получаем `doc_id`
2. `Post.objects.filter(semantic_doc_id__in=[...])` → полные посты

---

## 5. Реализация комбинированного поиска

### 5.1 Сценарии для блога

| Запрос пользователя | Как реализовать |
|---------------------|-----------------|
| "Похожие статьи" | `core.search_chunks(query, mode="vector")` |
| "Категория Python + похожее" | Фильтр в metadata: `{"category": "python"}` |
| "Категория + тег + похожее" | Каскадный фильтр или постфильтрация |

### 5.2 Хранение связей в metadata

При индексации поста сохраняем в metadata:

```
metadata = {
    "post_id": 42,
    "category_slug": "python",
    "category_id": 5,
    "tags": ["asyncio", "aiohttp"],
    "tag_ids": [12, 15],
    "published_at": "2025-01-15"
}
```

### 5.3 Поиск с фильтрацией

**Текущий API SemanticCore:**

- `metadata_filter` — точный матч по полям
- Можно комбинировать с семантическим поиском

**Для сложных фильтров:**

1. Получить результаты семантического поиска
2. Постфильтрация по Django ORM (категория + теги)
3. Объединение через RRF если нужен FTS

---

## 6. Пошаговый план миграции

### Этап 1: Подготовка (1-2 дня)

1. **Вынести логику из `routes/ingest.py`** в `IngestService`
2. **Документировать интерфейсы** сервисов (что принимают, что возвращают)
3. **Написать тесты** для сервисов без Flask-контекста

### Этап 2: Инфраструктура Django (2-3 дня)

1. Создать Django-проект с базовыми моделями (`Post`, `Category`, `Tag`)
2. Настроить конфигурацию SemanticCore через Django settings
3. Реализовать DI-механизм (singleton pattern или django-injector)

### Этап 3: Перенос сервисов (2-3 дня)

1. **Скопировать** `SearchService`, `ChatService` без изменений
2. **Переписать** `QueryCacheService` на Django ORM (или оставить Peewee)
3. **Создать** `IngestService` для блога с синхронизацией Post → SemanticCore

### Этап 4: Views и интеграция (3-4 дня)

1. Создать Django views, вызывающие сервисы
2. Реализовать HTMX-компоненты (синтаксис похож)
3. Настроить автоиндексацию при save/delete поста (signals)

### Этап 5: Тестирование и оптимизация (2-3 дня)

1. Integration tests для поиска с фильтрами
2. Проверка производительности
3. Настройка кэширования запросов

---

## 7. Рекомендации

### 7.1 Что переносить

- ✅ Сервисы (`SearchService`, `ChatService`) — копировать как есть
- ✅ DTOs — использовать напрямую
- ✅ Логику кэширования — адаптировать под Django ORM
- ✅ Markdown-утилиты — без изменений

### 7.2 Что писать заново

- ❌ Views — Django имеет свою философию
- ❌ Шаблоны — синтаксис Jinja2 ≠ Django templates
- ❌ Конфигурацию — Django settings вместо Pydantic Settings
- ❌ Модели кэша/чата — переписать на Django ORM

### 7.3 Что учесть

1. **Синхронизация данных** — при CRUD в Django обновлять SemanticCore
2. **Транзакции** — обернуть индексацию в Django transaction
3. **Удаление** — при удалении поста удалять из SemanticCore
4. **Миграции** — при изменении схемы поста переиндексация

---

## 8. Заключение

Flask-приложение спроектировано с хорошим разделением ответственности. **70% бизнес-логики** можно перенести в Django без существенных изменений.

**Ключевые решения для Django-блога:**

1. **Дублирование данных** — Django ORM для CRUD, SemanticCore для поиска
2. **Metadata linking** — хранить `post_id`, `category`, `tags` в метаданных чанков
3. **Signals** — автоматическая синхронизация при save/delete
4. **Service Layer** — сохранить архитектуру с выделенными сервисами

Общая оценка трудозатрат: **10-15 рабочих дней** для полной интеграции.
